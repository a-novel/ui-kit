{"version":3,"sources":["../../src/hooks/local-storage.ts"],"sourcesContent":["import { Dispatch, SetStateAction, useCallback, useEffect, useState } from \"react\";\n\nexport interface LocalStorageOptions {\n  /**\n   * <span style=\"color: #32adff;\">If true, initial value will be replaced by the localStorage content, even if it is\n   * null.</span>\n   */\n  replaceIfNull?: boolean;\n  /**\n   * <span style=\"color: #32adff;\">If true, the localStorage content is ignored at initialization.</span>\n   *\n   * The value will still be synced to localStorage when changed.\n   */\n  ignorePreviouslySavedValue?: boolean;\n}\n\n/**\n * <span style=\"color: #32adff;\">Sync a state with local storage.</span>\n */\nexport const useLocalStorageState = <T>(\n  localStorageKey: string,\n  initialValue: T | (() => T),\n  options: LocalStorageOptions = {},\n): [T, Dispatch<SetStateAction<T>>, boolean] => {\n  const { replaceIfNull, ignorePreviouslySavedValue } = options;\n\n  const [value, setValue] = useState<T>(initialValue as T);\n  const [loaded, setLoaded] = useState(false);\n\n  // Sync with local storage when value is updated.\n  const doSetValue = useCallback<Dispatch<SetStateAction<T>>>(\n    (setter) => {\n      if (!loaded) {\n        console.error(\n          \"setting localStorage value while being loaded can cause race conditions, and assign an unpredictable value. \" +\n            \"Please check for the loaded flag to be true before assigning any value.\",\n        );\n      }\n\n      setValue(setter);\n      localStorage.setItem(localStorageKey, JSON.stringify(value));\n    },\n    [loaded],\n  );\n\n  useEffect(() => {\n    if (loaded) return;\n\n    // Once this effect is ran, value and dispatcher can safely be used.\n    setLoaded(true);\n\n    // The previous value is ignored, but we still need to sync the current one to avoid inconsistency.\n    if (ignorePreviouslySavedValue) {\n      localStorage.setItem(localStorageKey, JSON.stringify(initialValue));\n      return;\n    }\n\n    // Retrieve saved value.\n    const savedValue = localStorage.getItem(localStorageKey);\n\n    if (savedValue != null || replaceIfNull) {\n      setValue(savedValue ? JSON.parse(savedValue) : null);\n    }\n  }, [loaded, ignorePreviouslySavedValue, localStorageKey, initialValue, replaceIfNull]);\n\n  return [value, doSetValue, loaded];\n};\n"],"names":["useCallback","useEffect","useState","useLocalStorageState","localStorageKey","initialValue","options","replaceIfNull","ignorePreviouslySavedValue","value","setValue","loaded","setLoaded","doSetValue","setter","console","error","localStorage","setItem","JSON","stringify","savedValue","getItem","parse"],"mappings":"AAAA,OAAmCA,WAAW,CAAEC,SAAS,CAAEC,QAAQ,KAAQ,OAAQ,AAmBnF,QAAO,MAAMC,qBAAuB,CAClCC,gBACAC,aACAC,QAA+B,CAAC,CAAC,IAEjC,KAAM,CAAEC,aAAa,CAAEC,0BAA0B,CAAE,CAAGF,QAEtD,KAAM,CAACG,MAAOC,SAAS,CAAGR,SAAYG,cACtC,KAAM,CAACM,OAAQC,UAAU,CAAGV,SAAS,OAGrC,MAAMW,WAAab,YACjB,AAACc,SACC,GAAI,CAACH,OAAQ,CACXI,QAAQC,KAAK,CACX,+GACE,0EAEN,CAEAN,SAASI,QACTG,aAAaC,OAAO,CAACd,gBAAiBe,KAAKC,SAAS,CAACX,OACvD,EACA,CAACE,OAAO,EAGVV,UAAU,KACR,GAAIU,OAAQ,OAGZC,UAAU,MAGV,GAAIJ,2BAA4B,CAC9BS,aAAaC,OAAO,CAACd,gBAAiBe,KAAKC,SAAS,CAACf,eACrD,MACF,CAGA,MAAMgB,WAAaJ,aAAaK,OAAO,CAAClB,iBAExC,GAAIiB,YAAc,MAAQd,cAAe,CACvCG,SAASW,WAAaF,KAAKI,KAAK,CAACF,YAAc,KACjD,CACF,EAAG,CAACV,OAAQH,2BAA4BJ,gBAAiBC,aAAcE,cAAc,EAErF,MAAO,CAACE,MAAOI,WAAYF,OAAO,AACpC,CAAE"}