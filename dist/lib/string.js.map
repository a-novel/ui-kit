{"version":3,"sources":["../../src/lib/string.ts"],"sourcesContent":["export interface NormalizeParams {\n  /**\n   * <span style=\"color: #32adff;\">Trim the string.</span>\n   *\n   * When set to true, the standard <span style=\"color: #ffd600;\">{@link String.trim trim method}</span> is called on\n   * the input.\n   */\n  trim?: boolean;\n  /**\n   * <span style=\"color: #32adff;\">Define a list of characters / characters combination to be used as separators.</span>\n   *\n   * Any character defined as a separator will be automatically trimmed at the start of the string. Plus, only\n   * <b>one consecutive separator</b> will be allowed between words.\n   */\n  separators?: string[];\n  /**\n   * <span style=\"color: #32adff;\">Keep leading separators.</span>\n   *\n   * This allows separators to be present at the start of the string, for editing purpose.\n   */\n  keepLeadingSeparator?: boolean;\n  /**\n   * <span style=\"color: #32adff;\">Sets a size limit for the string.</span>\n   *\n   * If the string length becomes larger than the value defined by max, the string will be truncated to the given\n   * length.\n   */\n  max?: number;\n  /**\n   * <span style=\"color: #32adff;\">Force the case of the string.</span>\n   *\n   * Characters that don't match the giving case will be converted automatically.\n   */\n  forceCase?: \"lower\" | \"upper\";\n  /**\n   * <span style=\"color: #32adff;\">Filter the content of the input.</span>\n   *\n   * Only the characters / groups of characters matching the given regular expression will be kept.\n   */\n  filter?: RegExp | string;\n}\n\n/**\n * <span style=\"color: #32adff;\">Apply advanced parsing to an input string.</span>\n *\n * Every available parsing operation is defined in the\n * <span style=\"color: #ffd600;\">{@link NormalizeParams configuration object}</span>.\n */\nexport class Normalizer {\n  private readonly params: Omit<NormalizeParams, \"filter\">;\n  private readonly filter?: RegExp;\n\n  constructor(params: NormalizeParams) {\n    this.params = params;\n    if (params.filter) this.filter = new RegExp(params.filter, \"gu\");\n  }\n\n  /**\n   * <span style=\"color: #32adff;\">Apply parser to an input string.</span>\n   *\n   * The output value is the result of executing all operations defined by the\n   * <span style=\"color: #ffd600;\">{@link NormalizeParams configuration object}</span> to this input.\n   */\n  exec = (value: string, params: Partial<NormalizeParams> = {}) => {\n    const actualParams = { ...this.params, ...params };\n    const actualFilter = actualParams.filter ? new RegExp(actualParams.filter, \"gu\") : this.filter;\n\n    if (actualParams.trim) {\n      value = value.trim();\n    }\n\n    if (actualParams.forceCase) {\n      value = actualParams.forceCase === \"lower\" ? value.toLowerCase() : value.toUpperCase();\n    }\n\n    if (actualParams.separators) {\n      let normalizedString = \"\";\n      // Since we don't want separators at the start of the string by default, we act as if an \"invisible\" separator\n      // is present.\n      let lastCharacterWasSeparator = !actualParams.keepLeadingSeparator;\n\n      while (value !== \"\") {\n        const initialSeparator = actualParams.separators?.find((separator) => value.startsWith(separator)) ?? \"\";\n\n        const addToNormalizedString =\n          // Don't add anything if the previous character was a separator and this version of the string also starts\n          // with a separator (no consecutive separators). Otherwise, add the separator, or the next character if this\n          // version of the string does not start with a separator.\n          lastCharacterWasSeparator && initialSeparator !== \"\" ? \"\" : initialSeparator || value[0];\n\n        normalizedString += addToNormalizedString;\n\n        value = value.slice(initialSeparator.length || 1);\n        lastCharacterWasSeparator = initialSeparator !== \"\";\n      }\n\n      value = normalizedString;\n    }\n\n    // It is important to execute filter near the end, because its result can depend on previous conditions\n    // (for example, if filter is set to only allow lowercase letters, then it can remove some unwanted\n    // characters if forceCase is set to \"lower\").\n    if (actualFilter) {\n      value = (value.match(actualFilter) || []).join(\"\");\n    }\n\n    // Execute max last, because previous conditions might have changed the length of the string.\n    if (actualParams.max) {\n      value = value.slice(0, this.params.max);\n    }\n\n    return value;\n  };\n}\n\n/**\n * <span style=\"color: #32adff;\">Normalized user data.</span>\n *\n * This generic representation is used to manage information display about a user.\n */\nexport interface UserData {\n  /**\n   * <span style=\"color: #32adff;\">Alias name for a user.</span>\n   *\n   * This fake name is used to hide a user true identity, and should be <b>used for display whenever available</b>.\n   */\n  username?: string;\n  firstName?: string;\n  lastName?: string;\n}\n\n/**\n * <span style=\"color: #32adff;\">Return the display name of a user.</span>\n *\n * Display name is computed from an <span style=\"color: #ffd600;\">{@link UserData user object data}</span>.\n * It returns the value that should be used as a public username.\n */\nexport const getDisplayName = (user: UserData) => {\n  if (user.username) {\n    return user.username;\n  }\n\n  if (user.firstName && user.lastName) {\n    return `${user.firstName} ${user.lastName}`;\n  }\n\n  if (user.firstName) {\n    return user.firstName;\n  }\n\n  if (user.lastName) {\n    return user.lastName;\n  }\n\n  return \"\";\n};\n"],"names":["Normalizer","params","filter","constructor","RegExp","exec","value","actualParams","actualFilter","trim","forceCase","toLowerCase","toUpperCase","separators","normalizedString","lastCharacterWasSeparator","keepLeadingSeparator","initialSeparator","find","separator","startsWith","addToNormalizedString","slice","length","match","join","max","getDisplayName","user","username","firstName","lastName"],"mappings":"AAgDA,OAAO,MAAMA,WACX,AAAiBC,MAAwC,AACzD,CAAiBC,MAAgB,AAEjCC,aAAYF,MAAuB,CAAE,CACnC,IAAI,CAACA,MAAM,CAAGA,OACd,GAAIA,OAAOC,MAAM,CAAE,IAAI,CAACA,MAAM,CAAG,IAAIE,OAAOH,OAAOC,MAAM,CAAE,KAC7D,CAQAG,KAAO,CAACC,MAAeL,OAAmC,CAAC,CAAC,IAC1D,MAAMM,aAAe,CAAE,GAAG,IAAI,CAACN,MAAM,CAAE,GAAGA,MAAM,AAAC,EACjD,MAAMO,aAAeD,aAAaL,MAAM,CAAG,IAAIE,OAAOG,aAAaL,MAAM,CAAE,MAAQ,IAAI,CAACA,MAAM,CAE9F,GAAIK,aAAaE,IAAI,CAAE,CACrBH,MAAQA,MAAMG,IAAI,EACpB,CAEA,GAAIF,aAAaG,SAAS,CAAE,CAC1BJ,MAAQC,aAAaG,SAAS,GAAK,QAAUJ,MAAMK,WAAW,GAAKL,MAAMM,WAAW,EACtF,CAEA,GAAIL,aAAaM,UAAU,CAAE,CAC3B,IAAIC,iBAAmB,GAGvB,IAAIC,0BAA4B,CAACR,aAAaS,oBAAoB,CAElE,MAAOV,QAAU,GAAI,CACnB,MAAMW,iBAAmBV,aAAaM,UAAU,EAAEK,KAAK,AAACC,WAAcb,MAAMc,UAAU,CAACD,aAAe,GAEtG,MAAME,sBAIJN,2BAA6BE,mBAAqB,GAAK,GAAKA,kBAAoBX,KAAK,CAAC,EAAE,CAE1FQ,kBAAoBO,sBAEpBf,MAAQA,MAAMgB,KAAK,CAACL,iBAAiBM,MAAM,EAAI,GAC/CR,0BAA4BE,mBAAqB,EACnD,CAEAX,MAAQQ,gBACV,CAKA,GAAIN,aAAc,CAChBF,MAAQ,AAACA,CAAAA,MAAMkB,KAAK,CAAChB,eAAiB,EAAE,AAAD,EAAGiB,IAAI,CAAC,GACjD,CAGA,GAAIlB,aAAamB,GAAG,CAAE,CACpBpB,MAAQA,MAAMgB,KAAK,CAAC,EAAG,IAAI,CAACrB,MAAM,CAACyB,GAAG,CACxC,CAEA,OAAOpB,KACT,CAAE,AACJ,CAwBA,OAAO,MAAMqB,eAAiB,AAACC,OAC7B,GAAIA,KAAKC,QAAQ,CAAE,CACjB,OAAOD,KAAKC,QAAQ,AACtB,CAEA,GAAID,KAAKE,SAAS,EAAIF,KAAKG,QAAQ,CAAE,CACnC,MAAO,CAAC,EAAEH,KAAKE,SAAS,CAAC,CAAC,EAAEF,KAAKG,QAAQ,CAAC,CAAC,AAC7C,CAEA,GAAIH,KAAKE,SAAS,CAAE,CAClB,OAAOF,KAAKE,SAAS,AACvB,CAEA,GAAIF,KAAKG,QAAQ,CAAE,CACjB,OAAOH,KAAKG,QAAQ,AACtB,CAEA,MAAO,EACT,CAAE"}