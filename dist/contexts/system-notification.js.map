{"version":3,"sources":["../../src/contexts/system-notification.tsx"],"sourcesContent":["import { ReactNode, createContext, useCallback, useContext, useRef, useState } from \"react\";\n\nimport { Color } from \"@components/common\";\nimport { ModalProps } from \"@components/layouts\";\n\nexport interface SystemNotification<Context> {\n  /**\n   * <span style=\"color: #32adff;\">Provide generic information about the notification.</span>\n   */\n  meta: SystemNotificationMetadata;\n  /**\n   * <span style=\"color: #32adff;\">Provide the current state of the notification.</span>\n   *\n   * State is used for applying special display effects to the notification.\n   */\n  state: SystemNotificationState;\n  /**\n   * <span style=\"color: #32adff;\">Provide the context of the notification.</span>\n   *\n   * Context is the data that will be used to display the notification. It is custom to each notification.\n   */\n  context: Context;\n}\n\nexport interface SystemNotificationMetadata {\n  /**\n   * <span style=\"color: #32adff;\">Mark the notification as important.</span>\n   *\n   * An important notification should use more aggressive delivery toward the user, as it may not miss it.\n   */\n  important?: boolean;\n  /**\n   * <span style=\"color: #32adff;\">Provide the color of the notification.</span>\n   *\n   * Use different colors for different levels of importance.\n   */\n  color: Exclude<Color, \"default\">;\n  /**\n   * <span style=\"color: #32adff;\">Provide the timeout after which the notification will be deleted.</span>\n   *\n   * Use this timeout to display smooth transitions when the notification is deleted.\n   */\n  deleteTimeout?: number;\n}\n\nexport interface SystemNotificationState {\n  /**\n   * <span style=\"color: #32adff;\">Mark the notification as being deleted.</span>\n   *\n   * This property is used to apply smooth transitions when the notification is deleted.\n   */\n  isDeleting: boolean;\n}\n\nexport type UpdateNotificationAction<Context> =\n  | {\n      method: \"upsert\";\n      meta: SystemNotificationMetadata;\n      context: Context;\n    }\n  | {\n      method: \"delete\";\n    };\n\nexport type NotificationUpdater<Context> =\n  | null\n  | UpdateNotificationAction<Context>\n  | ((key: string, previousNotification?: SystemNotification<Context>) => UpdateNotificationAction<Context> | null);\n\nconst useSystemNotificationsProvider = <Context,>() => {\n  const [notifications, setNotifications] = useState<Map<string, SystemNotification<Context>>>(new Map());\n  // Timers used for smooth removals. When a notification with a delay timeout is removed, its state is updated and its\n  // removal delayed to apply transitions.\n  const timers = useRef<Map<string, NodeJS.Timeout>>(new Map());\n\n  // Remove a timer, if it exists.\n  const cleanDeletionTimer = useCallback((key: string) => {\n    const timer = timers.current.get(key);\n    if (timer != null) clearTimeout(timer);\n    timers.current.delete(key);\n  }, []);\n\n  const deleteNotification = useCallback(\n    (key: string, immediate?: boolean) => {\n      setNotifications((prevState) => {\n        // Cancel previous timer, if any.\n        cleanDeletionTimer(key);\n\n        // Fetch the previous notification.\n        const notification = prevState.get(key);\n\n        // Nothing to delete.\n        if (notification == null) return prevState;\n\n        // No timer set, or we are called from a timer (immediate deletion).\n        if (!notification.meta.deleteTimeout || immediate) {\n          prevState.delete(key);\n          return new Map(prevState);\n        }\n\n        // Schedule deletion.\n        notification.state.isDeleting = true;\n        prevState.set(key, notification);\n\n        timers.current.set(\n          key,\n          setTimeout(() => deleteNotification(key, true), notification.meta.deleteTimeout),\n        );\n\n        return new Map(prevState);\n      });\n    },\n    [cleanDeletionTimer],\n  );\n\n  const upsertNotification = useCallback(\n    (key: string, meta: SystemNotificationMetadata, context: Context) => {\n      setNotifications((prevState) => {\n        // Cancel previous timer, if any.\n        cleanDeletionTimer(key);\n        prevState.set(key, { meta, context, state: { isDeleting: false } });\n        return new Map(prevState);\n      });\n    },\n    [cleanDeletionTimer],\n  );\n\n  const updateNotification = useCallback(\n    (key: string, updater: NotificationUpdater<Context>) => {\n      const notification = notifications.get(key);\n      const action = typeof updater === \"function\" ? updater(key, notification) : updater;\n\n      // no-op.\n      if (action == null) return;\n\n      switch (action.method) {\n        case \"upsert\":\n          upsertNotification(key, action.meta, action.context);\n          break;\n        case \"delete\":\n          deleteNotification(key);\n          break;\n      }\n    },\n    [deleteNotification, notifications, upsertNotification],\n  );\n\n  return { notifications, updateNotification };\n};\n\nexport interface SystemNotificationsContextType {\n  notifications: Map<string, SystemNotification<SystemNotificationContextDefault>>;\n  updateNotification: (key: string, updater: NotificationUpdater<SystemNotificationContextDefault>) => void;\n}\n\nexport const SystemNotificationsContext = createContext<SystemNotificationsContextType>({\n  notifications: new Map(),\n  updateNotification: () => {\n    console.warn(\n      \"An attempt was made to call SystemNotificationsContext.updateNotification, but this context has not been initialized\",\n    );\n  },\n});\n\nexport interface SystemNotificationsProviderProps {\n  children: ReactNode;\n}\n\nexport const SystemNotificationsProvider = ({ children }: SystemNotificationsProviderProps) => {\n  const provider = useSystemNotificationsProvider<SystemNotificationContextDefault>();\n  return <SystemNotificationsContext.Provider value={provider}>{children}</SystemNotificationsContext.Provider>;\n};\n\nexport const useSystemNotifications = () => {\n  return useContext(SystemNotificationsContext);\n};\n\nexport interface SystemNotificationContextDefault {\n  /**\n   * <span style=\"color: #32adff;\">Icon of the notification.</span>\n   *\n   * This is the required icon shown in the left part of the notification.\n   */\n  icon: ReactNode;\n  /**\n   * <span style=\"color: #32adff;\">Title of the notification.</span>\n   *\n   * Should be short and catchy, instantly giving the user an idea of what the notification is about.\n   */\n  title: ReactNode;\n  /**\n   * <span style=\"color: #32adff;\">Content of the notification.</span>\n   *\n   * Give a short description of the notification, to add more context. If you need a larger context, use the\n   * notification modal property.\n   */\n  content: ReactNode;\n  /**\n   * <span style=\"color: #32adff;\">Mark the notification as read.</span>\n   *\n   * A read notification should not be displayed again to the user.\n   */\n  read?: boolean;\n  /**\n   * <span style=\"color: #32adff;\">Provide extra data to the notification.</span>\n   */\n  extra?: unknown;\n  /**\n   * <span style=\"color: #32adff;\">Provide a modal to display when the notification is clicked.</span>\n   *\n   * This property should not be set together with the href property.\n   */\n  modal?: Pick<ModalProps, \"children\" | \"title\">;\n  /**\n   * <span style=\"color: #32adff;\">Provide a link to redirect to when the notification is clicked.</span>\n   *\n   * This property should not be set together with the modal property.\n   */\n  href?: string;\n}\n"],"names":["createContext","useCallback","useContext","useRef","useState","useSystemNotificationsProvider","notifications","setNotifications","Map","timers","cleanDeletionTimer","key","timer","current","get","clearTimeout","delete","deleteNotification","immediate","prevState","notification","meta","deleteTimeout","state","isDeleting","set","setTimeout","upsertNotification","context","updateNotification","updater","action","method","SystemNotificationsContext","console","warn","SystemNotificationsProvider","children","provider","Provider","value","useSystemNotifications"],"mappings":"0CAAA,QAAoBA,aAAa,CAAEC,WAAW,CAAEC,UAAU,CAAEC,MAAM,CAAEC,QAAQ,KAAQ,OAAQ,CAqE5F,MAAMC,+BAAiC,KACrC,KAAM,CAACC,cAAeC,iBAAiB,CAAGH,SAAmD,IAAII,KAGjG,MAAMC,OAASN,OAAoC,IAAIK,KAGvD,MAAME,mBAAqBT,YAAY,AAACU,MACtC,MAAMC,MAAQH,OAAOI,OAAO,CAACC,GAAG,CAACH,KACjC,GAAIC,OAAS,KAAMG,aAAaH,OAChCH,OAAOI,OAAO,CAACG,MAAM,CAACL,IACxB,EAAG,EAAE,EAEL,MAAMM,mBAAqBhB,YACzB,CAACU,IAAaO,aACZX,iBAAiB,AAACY,YAEhBT,mBAAmBC,KAGnB,MAAMS,aAAeD,UAAUL,GAAG,CAACH,KAGnC,GAAIS,cAAgB,KAAM,OAAOD,UAGjC,GAAI,CAACC,aAAaC,IAAI,CAACC,aAAa,EAAIJ,UAAW,CACjDC,UAAUH,MAAM,CAACL,KACjB,OAAO,IAAIH,IAAIW,UACjB,CAGAC,aAAaG,KAAK,CAACC,UAAU,CAAG,KAChCL,UAAUM,GAAG,CAACd,IAAKS,cAEnBX,OAAOI,OAAO,CAACY,GAAG,CAChBd,IACAe,WAAW,IAAMT,mBAAmBN,IAAK,MAAOS,aAAaC,IAAI,CAACC,aAAa,GAGjF,OAAO,IAAId,IAAIW,UACjB,EACF,EACA,CAACT,mBAAmB,EAGtB,MAAMiB,mBAAqB1B,YACzB,CAACU,IAAaU,KAAkCO,WAC9CrB,iBAAiB,AAACY,YAEhBT,mBAAmBC,KACnBQ,UAAUM,GAAG,CAACd,IAAK,CAAEU,KAAMO,QAASL,MAAO,CAAEC,WAAY,KAAM,CAAE,GACjE,OAAO,IAAIhB,IAAIW,UACjB,EACF,EACA,CAACT,mBAAmB,EAGtB,MAAMmB,mBAAqB5B,YACzB,CAACU,IAAamB,WACZ,MAAMV,aAAed,cAAcQ,GAAG,CAACH,KACvC,MAAMoB,OAAS,OAAOD,UAAY,WAAaA,QAAQnB,IAAKS,cAAgBU,QAG5E,GAAIC,QAAU,KAAM,OAEpB,OAAQA,OAAOC,MAAM,EACnB,IAAK,SACHL,mBAAmBhB,IAAKoB,OAAOV,IAAI,CAAEU,OAAOH,OAAO,EACnD,KACF,KAAK,SACHX,mBAAmBN,KACnB,KACJ,CACF,EACA,CAACM,mBAAoBX,cAAeqB,mBAAmB,EAGzD,MAAO,CAAErB,cAAeuB,kBAAmB,CAC7C,CAOA,QAAO,MAAMI,2BAA6BjC,cAA8C,CACtFM,cAAe,IAAIE,IACnBqB,mBAAoB,KAClBK,QAAQC,IAAI,CACV,uHAEJ,CACF,EAAG,AAMH,QAAO,MAAMC,4BAA8B,CAAC,CAAEC,QAAQ,CAAoC,IACxF,MAAMC,SAAWjC,iCACjB,OAAO,KAAC4B,2BAA2BM,QAAQ,EAACC,MAAOF,kBAAWD,UAChE,CAAE,AAEF,QAAO,MAAMI,uBAAyB,KACpC,OAAOvC,WAAW+B,2BACpB,CAAE"}